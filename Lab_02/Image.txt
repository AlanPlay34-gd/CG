const vec3 GRADIENT_STEP = vec3(0.001, 0.0, 0.0);
const int MAX_MARCHING_STEPS = 80;
const float MIN_DIST = 0.;
const float MAX_DIST = 30.;
const float PRECISION = .001;
const float FOV = 0.9;
//Hash

float hash(vec2 p) {
    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
}

vec2 hash2(vec2 p) {
    return fract(sin(vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3))))*43758.5453);
}


//SDF functions
float sdSphere(vec3 p, float r){
    return length(p) - r;
}

float sdBox(vec3 p, vec3 b){
    vec3 q = abs(p) - b;
    return length(max(q,0.0)) + min(max(q.x, max(q.y,q.z)),0.0);
}

float sdCylinder( vec3 p, vec3 a, vec3 b, float r ){
  vec3  ba = b - a;
  vec3  pa = p - a;
  float baba = dot(ba,ba);
  float paba = dot(pa,ba);
  float x = length(pa*baba-ba*paba) - r*baba;
  float y = abs(paba-baba*0.5)-baba*0.5;
  float x2 = x*x;
  float y2 = y*y*baba;
  float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));
  return sign(d)*sqrt(abs(d))/baba;
}

float sdRoundedCylinder( vec3 p, float ra, float rb, float h ){
  vec2 d = vec2( length(p.yz)-ra+rb, abs(p.x) - h + rb );
  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;
}

float sdLink( vec3 p, float le, float r1, float r2 ){
  vec3 q = vec3( p.y, max(abs(p.z)-le,0.0), p.x );
  return length(vec2(length(q.xy)-r1,q.z)) - r2;
}

float sdBullet(vec3 p) {
    vec4 bulletData = texelFetch(iChannel1, ivec2(0, 0), 0);
    
    if (bulletData.w > 0.0) {
        return length(p - bulletData.xyz) - 0.1;
    }
    
    return MAX_DIST;
}

float sdBomb(vec3 p) {
    vec3 bp = p;
    return sdSphere(bp,.08);
}
 
 
//Tools for transform
mat3 rotateX(float a) {
    float c = cos(a);
    float s = sin(a);
    return mat3(
        vec3(1, 0, 0),
        vec3(0, c, -s),
        vec3(0, s, c)
    );
}

mat3 rotateY(float a) {
    float c = cos(a);
    float s = sin(a);
    return mat3(
        vec3(c, 0, s),
        vec3(0, 1, 0),
        vec3(-s, 0, c)
    );
}

mat3 rotateZ(float a) {
    float c = cos(a);
    float s = sin(a);
    return mat3(
        vec3(c, -s, 0),
        vec3(s, c, 0),
        vec3(0, 0, 1)
    );
}

// Obj struct
struct Object {
    float dist;
    int material;
};
// Complex SDF function


Object sdPlayer(vec3 p){
    vec3 playerPos = p;
    vec3 spherePos = vec3(0.,0.5,0.);
    float sphere = sdSphere(playerPos * 2. - spherePos,1.)/2.;
    
    vec2 keyboard = texelFetch(iChannel0, ivec2(0,0),0).xy;
    
    vec3 q = vec3(0.,0.5,1.25);
    q *= rotateX(keyboard.y);
    q *= rotateY(keyboard.x);
    float cylinder = sdCylinder(playerPos, vec3(0.,0.5,0.), q, 0.1);
    
    float box = sdBox(playerPos * 2., vec3(1.5,.5,2.)) /2.;
    
    float wheel = min(
    sdRoundedCylinder(playerPos - vec3(0.,0.,-.8), .2, .1, .9),
 min(sdRoundedCylinder(playerPos - vec3(0.,0.,-.4), .2, .1, .9),
 min(sdRoundedCylinder(playerPos - vec3(0.,0.,0.), .2, .1, .9),
 min(sdRoundedCylinder(playerPos - vec3(0.,0.,.4), .2, .1, .9),
 sdRoundedCylinder(playerPos - vec3(0.,0.,.8), .2, .1, .9)))));
    
    float track = min(sdLink(playerPos - vec3(.8,0.,0.),.85,0.25, 0.1),sdLink(playerPos- vec3(-.8,0.,0.),.85,0.25, 0.1));
    
    float minDist = min(sphere, min(cylinder,min(box,min(wheel,track))));
    
    int mat = 0;
    if (minDist == sphere) {
        mat = 2;
    } else if (minDist == box) {
        mat = 3;
    } else if (minDist == cylinder) {
        mat = 4;
    } else if (minDist == track){
        mat = 5;
    } else if (minDist == wheel){
        mat = 6;
    }
    return Object(minDist,mat);
}
Object sdEnemy(vec3 p){
    vec3 enemyPos = p;
    vec3 spherePos = vec3(0.,0.5,0.);
    float sphere = sdSphere(enemyPos * 2. - spherePos,1.)/2.;
    
    vec3 q = vec3(0.,0.5,1.25);
    float cylinder = sdCylinder(enemyPos, vec3(0.,0.5,0.), q, 0.1);
    
    float box = sdBox(enemyPos * 2., vec3(1.5,.5,2.)) /2.;
    
    float wheel = min(
    sdRoundedCylinder(enemyPos - vec3(0.,0.,-.8), .2, .1, .9),
 min(sdRoundedCylinder(enemyPos - vec3(0.,0.,-.4), .2, .1, .9),
 min(sdRoundedCylinder(enemyPos - vec3(0.,0.,0.), .2, .1, .9),
 min(sdRoundedCylinder(enemyPos - vec3(0.,0.,.4), .2, .1, .9),
 sdRoundedCylinder(enemyPos - vec3(0.,0.,.8), .2, .1, .9)))));
    
    float track = min(sdLink(enemyPos - vec3(.8,0.,0.),.85,0.25, 0.1),sdLink(enemyPos- vec3(-.8,0.,0.),.85,0.25, 0.1));float minDist = min(sphere, min(cylinder,min(box,min(wheel,track))));
    
    int mat = 0;
    if (minDist == sphere) {
        mat = 7;
    } else if (minDist == box) {
        mat = 8;
    } else if (minDist == cylinder) {
        mat = 4;
    } else if (minDist == track){
        mat = 5;
    } else if (minDist == wheel){
        mat = 6;
    }
    return Object(minDist,mat);
}
Object sdFly(vec3 p, int i){
    int mat = 0;
    
    vec3 right = texelFetch(iChannel2, ivec2(i, 1), 0).xyz;
    vec3 up = texelFetch(iChannel2, ivec2(i, 2), 0).xyz;
    vec3 dir = texelFetch(iChannel2, ivec2(i, 3), 0).xyz;
    mat3 rot = mat3(right, up, dir);

    vec3 local = p - texelFetch(iChannel2, ivec2(i, 0), 0).xyz;
    local = local * rot;

    float wings     = sdBox(local + vec3(0.0, 0.0, 0.0), vec3(0.5, 0.02, 0.2));
    float body      = sdBox(local + vec3(0.0, 0.0, 0.2), vec3(0.1, 0.07, 0.6));
    float propeller = sdBox(local + vec3(0.0, 0.0, -0.4), vec3(0.2, 0.1, 0.05));
    
    vec3 bombPos = texelFetch(iChannel2, ivec2(i, 4), 0).xyz;
    float bomb = sdBomb(p - bombPos);
    
    float minDist = min(min(min(body, wings), propeller),bomb);
    if (minDist == body || minDist == wings || minDist == propeller)
        mat = 10;
    else if(minDist == bomb){
        mat = 0;
    }
    return Object(minDist, mat);
}

vec3 getCraterColor(vec3 craterPos) {
    float r = hash(craterPos.xy);
    float g = hash(craterPos.yz);
    float b = hash(craterPos.zx);
    
    r = 0.4 + 0.5 * r;
    g = 0.4 + 0.5 * g;
    b = 0.2 + 0.5 * b;
    
    return vec3(r, g, b);
}

vec3 getGroundColor(vec3 p, vec3 normal) {
    vec3 baseColor = vec3(0.0, 0.9, 0.0);
    
    int holeCount1 = int(texelFetch(iChannel3, ivec2(0, 0), 0).r);
    int holeCount2 = int(texelFetch(iChannel3, ivec2(1, 0), 0).r);
    
    for (int k = 0; k < holeCount1; k++) {
        vec4 holeData = texelFetch(iChannel3, ivec2(0, k+1), 0);
        vec3 holePos = holeData.rgb;
        
        float dist = length(p.xz - holePos.xz);
        float crater = 0.6 * exp(-dist * dist / 0.5);
        
        if (crater > 0.1) {
            return getCraterColor(holePos);
        }
    }
     
    for (int k = 0; k < holeCount2; k++) {
        vec4 holeData = texelFetch(iChannel3, ivec2(1, k+1), 0);
        vec3 holePos = holeData.rgb;
        
        float dist = length(p.xz - holePos.xz);
        float crater = 0.6 * exp(-dist * dist / 0.5);
        
        if (crater > 0.1) {
            return getCraterColor(holePos);
        }
    }
    
    return baseColor;
}
    
Object map(vec3 p){
    Object player = sdPlayer(p);
    Object enemy = sdEnemy(p+vec3(10.,0.,10.));
    Object fly = sdFly(p - vec3(0.,3.,0.),3);
    Object fly2 = sdFly(p - vec3(0.,3.,0.),5);
    
    float ground = p.y + 0.4;
    
    
    //пули
    float bulletDist = MAX_DIST;
    vec4 bulletData = texelFetch(iChannel1, ivec2(1, 0), 0);
    if (bulletData.w > 0.0) {
        bulletDist = length(p - bulletData.xyz) - 0.08;
    }
    
    int holeCount1 = int(texelFetch(iChannel3, ivec2(0, 0), 0).r);
    int holeCount2 = int(texelFetch(iChannel3, ivec2(1, 0), 0).r);
    
    for (int k = 0; k < holeCount1; k++) {
        vec4 holeData = texelFetch(iChannel3, ivec2(0, k+1), 0);
        vec3 holePos = holeData.rgb;
        
            float dist = length(p.xz - holePos.xz);
            float crater = 0.6 * exp(-dist * dist / 0.5);
            ground += crater;
        
    }
     
    for (int k = 0; k < holeCount2; k++) {
        vec4 holeData = texelFetch(iChannel3, ivec2(1, k+1), 0);
        vec3 holePos = holeData.rgb;
        
        
            float dist = length(p.xz - holePos.xz);
            float crater = 0.6 * exp(-dist * dist / 0.5);
            ground += crater;
        
    }

    
    float minDist = min(ground, min(player.dist, min(enemy.dist, min(fly.dist, min(fly2.dist, bulletDist)))));


    int material = 0;
    
    if (minDist == ground) {
        material = 1;
    } else if (minDist == player.dist) {
        material = player.material;
    } else if (minDist == enemy.dist){
        material = enemy.material;
    } else if (minDist == bulletDist) {
        material = 9;
    }else if(minDist == fly.dist || minDist == fly2.dist){
        material = fly.material;
    }
    
    return Object(minDist, material);
}
//Materials Interpritation
vec3 getMaterialColor(int material, vec3 p, vec3 normal) {
    if (material == 1) { // ground
        return getGroundColor(p, normal);
    } else if (material == 2) { // Bashnya
        return vec3(0., .6, .0);
    } else if (material == 3) { // Body
        return vec3(0., .6, .0);
    } else if (material == 4) { // Dulo
        return vec3(.3, .3, .3); 
    } else if (material == 5) { // Гусеница
        return vec3(.1, .1, .1); 
    } else if (material == 6) { // Колеса
        return vec3(0., .3, 0.); 
    } else if (material == 7) { // Прот башня
        return vec3(5., .0, 0.); 
    } else if (material == 8) { // Прот body
        return vec3(8., .0, 0.); 
    }else if (material == 9) { // Пули
        return vec3(1.0, 1.0, 0.0);
    }else if (material == 10){//Самолета
        return vec3(1.0, 0.0, 0.0);
    }
    return vec3(1.0, 1.0, 1.0);
}


float softShadow(vec3 ro, vec3 rd, float mint, float maxt, float k) {
    float res = 1.0;
    float ph = 1e20;
    for(float t = mint; t < maxt;) {
        float h = map(ro + rd * t).dist;
        if(h < PRECISION) 
            return 0.0;
        float y = h*h/(2.0*ph);
        float d = sqrt(h*h-y*y);
        res = min(res, k*d/max(0.0,t-y));
        ph = h;
        t += h;
    }
    return res;
}

vec3 calculateLight(vec3 p, vec3 normal, vec3 viewDir, vec3 color) {
    vec3 sunDir = normalize(vec3(0.5, 1.0, -0.7));
    vec3 sunColor = vec3(1.0, 0.98, 0.95);

    float shadow = softShadow(p + normal * 0.01, sunDir, 0.02, 10.0, 8.0);
    
    // Диффузное освещение
    float diff = max(dot(normal, sunDir), 0.0);
    vec3 diffuse = sunColor * diff * shadow;
    
    float halfLambert = diff * 0.5 + 0.5;
    vec3 halfLambertDiffuse = sunColor * halfLambert * halfLambert * shadow;
    
    vec3 result = color * halfLambertDiffuse;
    
    return result;
}

//Ray Matching fucntion
Object rayMarch(vec3 ro, vec3 rd, float start, float end) {
  float depth = start;
  int mat = 0;
  
  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {
    vec3 p = ro + rd * depth;
    Object d = map(p);
    depth += d.dist;
    mat = d.material;
    if (d.dist < PRECISION || depth > end) break;
  }

  return Object(depth,mat);
}

// функция для light
vec3 calcNormal(vec3 p) {
    vec2 e = vec2(1.0, -1.0) * 0.0005;
    return normalize( e.xyy * map(p + e.xyy).dist + e.yyx * map(p + e.yyx).dist +
      e.yxy * map(p + e.yxy).dist + e.xxx * map(p + e.xxx).dist);
}

void mainImage( out vec4 fragColor, in vec2 fragCoord ){
    
    //Base settings
    vec2 uv = (fragCoord *2. - iResolution.xy) / iResolution.y;
    vec2 m = (iMouse.xy *2. - iResolution.xy) / iResolution.y;
    //Intialization
    vec3 ro = vec3(0.,0.,-10.);
    vec3 rd = normalize(vec3(uv * FOV,1.));
    vec3 col = vec3(0.);
    
    //"Camera Rotation"
    //Vertical Mouse Rotation;
    ro *= rotateX(-m.y*3.14159);
    rd *= rotateX(-m.y*3.14159);
    //Horizontal Mouse Rotation
    ro *= rotateY(-m.x* 6.28318);
    rd *= rotateY(-m.x* 6.28318);
    
    
    
    Object result = rayMarch(ro, rd, MIN_DIST, MAX_DIST);
    float d = result.dist;
    
    if (d < MAX_DIST) {
        vec3 p = ro + rd * d;
        Object obj = map(p);
        vec3 normal = calcNormal(p);

        vec3 materialColor = getMaterialColor(result.material, p, normal); 

        vec3 viewDir = normalize(ro - p);
        
        col = calculateLight(p, normal, viewDir, materialColor);
        
        col *= exp(-d * 0.02);
        col = mix(col, vec3(0.7, 0.8, 1.0), 1.0 - exp(-d * 0.02));
       

    } else {
        col = mix(vec3(0.5, 0.7, 1.0), vec3(1.0, 1.0, 1.0), uv.y * 0.5 + 0.5);
    }
    
    
    fragColor = vec4(col,1.);
}
